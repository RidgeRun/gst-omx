Index: gst-plugins-good-1.6.1/src/sys/v4l2/gstv4l2bufferpool.c
===================================================================
--- gst-plugins-good-1.6.1.orig/src/sys/v4l2/gstv4l2bufferpool.c	2016-03-02 14:47:35.352319500 -0600
+++ gst-plugins-good-1.6.1/src/sys/v4l2/gstv4l2bufferpool.c	2016-03-02 14:52:37.272314326 -0600
@@ -548,7 +548,10 @@
 
   if (min_buffers < GST_V4L2_MIN_BUFFERS) {
     updated = TRUE;
-    min_buffers = GST_V4L2_MIN_BUFFERS;
+    if (obj->queue_size < GST_V4L2_MIN_BUFFERS)
+      min_buffers = GST_V4L2_MIN_BUFFERS;
+    else
+      min_buffers = obj->queue_size;
     GST_INFO_OBJECT (pool, "increasing minimum buffers to %u", min_buffers);
   }
 
Index: gst-plugins-good-1.6.1/src/sys/v4l2/gstv4l2object.c
===================================================================
--- gst-plugins-good-1.6.1.orig/src/sys/v4l2/gstv4l2object.c	2016-03-02 14:47:35.364319499 -0600
+++ gst-plugins-good-1.6.1/src/sys/v4l2/gstv4l2object.c	2016-03-02 14:54:03.656312845 -0600
@@ -3721,6 +3721,7 @@
      * pool, we'll need what the driver one, and one more, so we can dequeu */
     own_min = obj->min_buffers + 1;
     own_min = MAX (own_min, GST_V4L2_MIN_BUFFERS);
+    own_min = MAX (own_min, obj->queue_size);
 
     /* for the downstream pool, we keep what downstream wants, though ensure
      * at least a minimum if downstream didn't suggest anything (we are
Index: gst-plugins-good-1.6.1/src/sys/v4l2/gstv4l2src.c
===================================================================
--- gst-plugins-good-1.6.1.orig/src/sys/v4l2/gstv4l2src.c	2015-10-22 02:02:54.000000000 -0600
+++ gst-plugins-good-1.6.1/src/sys/v4l2/gstv4l2src.c	2016-03-02 14:53:42.776313203 -0600
@@ -63,12 +63,14 @@
 #define GST_CAT_DEFAULT v4l2src_debug
 
 #define DEFAULT_PROP_DEVICE   "/dev/video0"
+#define DEFAULT_PROP_QUEUE_SIZE 6
 
 enum
 {
   PROP_0,
   V4L2_STD_OBJECT_PROPS,
-  PROP_LAST
+  PROP_LAST,
+  PROP_QUEUESIZE
 };
 
 /* signals and args */
@@ -138,6 +140,11 @@
   gobject_class->set_property = gst_v4l2src_set_property;
   gobject_class->get_property = gst_v4l2src_get_property;
 
+  g_object_class_install_property (gobject_class, PROP_QUEUESIZE,
+      g_param_spec_uint ("queue-size", "size of the queue",
+          "Number of buffers to be enqueued in the driver in streaming mode",
+          1, 16, 6, G_PARAM_WRITABLE));
+
   element_class->change_state = gst_v4l2src_change_state;
 
   gst_v4l2_object_install_properties_helper (gobject_class,
@@ -200,6 +207,7 @@
       V4L2_BUF_TYPE_VIDEO_CAPTURE, DEFAULT_PROP_DEVICE,
       gst_v4l2_get_input, gst_v4l2_set_input, NULL);
 
+  v4l2src->v4l2object->queue_size = DEFAULT_PROP_QUEUE_SIZE;
   gst_base_src_set_format (GST_BASE_SRC (v4l2src), GST_FORMAT_TIME);
   gst_base_src_set_live (GST_BASE_SRC (v4l2src), TRUE);
 }
@@ -223,6 +231,9 @@
   if (!gst_v4l2_object_set_property_helper (v4l2src->v4l2object,
           prop_id, value, pspec)) {
     switch (prop_id) {
+      case PROP_QUEUESIZE:
+	v4l2src->v4l2object->queue_size = g_value_get_uint (value);
+	break;
       default:
         G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
         break;
@@ -239,6 +250,9 @@
   if (!gst_v4l2_object_get_property_helper (v4l2src->v4l2object,
           prop_id, value, pspec)) {
     switch (prop_id) {
+      case PROP_QUEUESIZE:
+	g_value_set_uint (value, v4l2src->v4l2object->queue_size);
+	break;
       default:
         G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
         break;
Index: gst-plugins-good-1.6.1/src/sys/v4l2/gstv4l2object.h
===================================================================
--- gst-plugins-good-1.6.1.orig/src/sys/v4l2/gstv4l2object.h	2015-10-22 02:02:54.000000000 -0600
+++ gst-plugins-good-1.6.1/src/sys/v4l2/gstv4l2object.h	2016-03-02 14:54:46.528312110 -0600
@@ -171,6 +171,9 @@
   /* Allow to skip reading initial format through G_FMT. Some devices
    * just fails if you don't call S_FMT first. (ex: M2M decoders) */
   gboolean no_initial_format;
+
+  /* Number of buffers to be enqueued in the driver in streaming mode  */
+  guint queue_size;
 };
 
 struct _GstV4l2ObjectClassHelper {
